# 第1章 编译概述

## 1.1 翻译程序与编译程序
- 翻译程序：把源语言所写的源程序翻译成等价的目标语言的程序(即目标程序)。 
- 编译程序：编译程序也是一种翻译程序，将高级语言所写的源程序翻译成等价的机器语言或汇编语言的目标程序。 

程序运行阶段：
![d6MmWj.png](https://s1.ax1x.com/2020/08/25/d6MmWj.png)

## 1.2 编译过程与编译程序的基本结构 
### 1.2.1编译过程:
#### 1. 词法分析
对构成源程序的字符串从左到右进行扫描和分解，根据语言的词法规则，识别出一个一个具有独立意义的单词( 也称单词符号, 简称符号 )。

- 词法规则：单词符号的形成规则,规定了哪些字符串构成一个单词符号。

例：计算圆柱体的表面积
float r , h , s ;
s = 2 * 3.1416 * r * (r+h) ;
其中单词符号有：
基本字：float    标识符：r、h、s    常数：3.1416、2    算符：*、+    界符：“、”、；、，、=
#### 2. 语法分析
在词法分析的基础上,  根据语言的语法规则从单词符号串中识别出各种语法单位 ( 如表达式、说明、语句等 ) ,并进行语法检查,即检查各种语法单位在语法结构上的正确性。  

- 语法规则：规定了单词符号如何形成语法单位，语法规则是语法单位的形成规则。 

上述例子中：
单词符号串 s = 2 * 3.1416 * r * (h＋r)中，“s” 是<变量>，单词符号串“2 * 3.1416 * r * (h+r)”组成表达式，“变量=表达式”构成赋值语句。
#### 3. 语义分析和中间代码生成

- 语义分析：首先对每种语法单位进行静态的语义审查，然后分析其含义，并用另一种语言形式 (比源语言更接近于目标语言的一种中间代码或直接用目标语言 ) 来描述这种语义。

上述例子的中间代码如下：
（1） （ * ，  2   ， 3.1416 ， T1 ) 
（2） （ * ， T1  ，      r     ， T2 ) 
（3） （ + ， h   ，      r    ， T3  ) 
（4） （ * ， T2  ，     T3   ， T4  ) 
（5） （ = ， T4 ，     __    ，  s   ) 

#### 4. 代码优化
对前阶段产生的中间代码进行等价变换或改造，以期获得更为高效即省时间和空间的目标代码。

- 优化主要包括局部优化和循环优化

上述例子中间代码经局部优化后得：
（1） （ * ，6.28 ，     r    ， T2   ) 

（2） （ + ， h   ，      r    ， T3  ) 
（3） （ * ， T2  ，     T3   ， T4  ) 
（4） （ = ， T4 ，     __    ，  s   ) 
#### 5. 目标代码生成
将中间代码变换成特定机器上的绝对指令代码或可重定位的指令代码或汇编指令代码。 
### 1.2.2编译程序的结构
![d6MuSs.png](https://s1.ax1x.com/2020/08/25/d6MuSs.png)
## 1.3编译程序的生成方法

- 自动生成系统：LEX、YACC
- 生成方法：自编译、移植、自动并行编译
## 1.4编译技术在软件开发中的应用

- 设计词法分析器的串匹配技术已用于正文编辑器、信息检索系统和模式识别程序
- 上下文无关文法和语法制导定义已用于创建诸如排版、绘图系统和语言结构化编辑器中
- 代码优化技术已用于程序验证器和从非结构化的程序产生结构化程序的编程之中。 

# 第2章 文法和语言的基本知识

## 2.1 概述

描述程序设计语言的三个因素：

1. 语法：对语言结构的定义
1. 语义：语言的含义
1. 语用：从使用者的角度描述

- 形式语言理论是编译的重要理论基础

## 2.2 字母表和符号串的基本概念

### 2.2.1 字母表和符号串

#### 1. 字母表

元素的非空有穷集合
例：Σ={a，b，c，0}中，Σ是字母表，由a、b、c、0四个元素组成
注：

1. 字母表中是少包含一个元素
1. 字母表中的元素可以是字母、数字或其他符号

#### 2. 符号（字符）

字母表中的元素
上述例子中的a、b、c、0是字母表Σ的符号

#### 3. 符号串（字）

符号的用穷序列
上述例子中有符号串：a、b、ab、ba、abc......

- 符号串总是建立在某个特定字母表上且只由字母表上的有穷多个符号组成
- 符号串中符号的顺序不同意义也不同
- 不包含任何符号的符号串，称为空符号串，用ε表示，长度为0

### 2.2.2 符号串的运算

#### 1. 符号串的连结

设x和y是符号串，则串xy称为它们的连结
例：设X＝ABC，Y＝10A，则XY＝ABC10A，YX＝10AABC

- 对任意一个符号串x，我们有 εx ＝ xε ＝ x

#### 2. 集合的乘积

设A和B是符号串的集合, 则A和B的乘积定义为：AB={xy | x∈A, y∈B}
例：设A={ a, b }, B={ c, d }，则AB={ ac, ad, bc, bd }
由于对任意的符号串x，总有εx=xε=x
所以, 对任意集合A, 我们有:{ε}A ＝ A{ε} ＝ A

- ε 是符号串, 不是集合，而{ε}表示由空符号串 ε 所组成的集合, 不是空集合Φ={} 

#### 3. 符号串的幂运算

设x是符号串, 则x的幂运算定义为：  
x的0次方  = ε ≠1
x的一次方 = x
x的二次方 = xx
......

#### 4. 集合的幂运算

设A是符号串的集合，则集合A的幂运算定义为：
A的0次方  = {ε}
A的一次方 = A
A的平方 = AA

#### 5. 集合A的正闭包A＋与闭包A*（+、*在右上角）

设A是符号串的集合，则A的正闭包A＋和A的闭包A*的定义为:
A+=A∪A的平方∪ … ∪A的n次方 …
A*= A的0次方∪ A∪A的平方∪ … ∪A的n次方 …
    ={ε}∪A+
例：设A={ a, b }, 则：A+={ a, b, aa, ab, ba, bb, aaa, aab, …}
      A*={ ε, a, b, aa, ab, ba, bb, aaa, aab, …}

- 集合A的正闭包表示A上元素a,b构成的所有符号串的集合
- 集合A的闭包比集合A的正闭包多含一个空符号串ε

## 2.3 **文法和语言的形式定义**

### 2.3.1 形式语言

序列的集合称为形式语言

- 每个形式语言都是某个字母表上按某种规则构成的所有符号串的集合
- 任何一个字母表上符号串的集合均可定义为一个形式语言

形式语言的描述方法：

1. 当语言为有穷集合时，用枚举法描述

例：设有字母表A={ a, b, c }，则L1={ a, b, c }，L2={ a, aa, ab, ac }，L3={ c, cc }

2. 当语言为无穷集合时，用文法来描述

例：设字母表∑={ 0, 1 }, 则∑+=∑1∪∑2∪∑3∪…
    ={ 0, 1, 00, 10, 11, 01, 000, 100, …}
用A表示∑+，用式子A→0表示符号串0∈A或A生成符号串0，
符号“→”读作“生成”或“由…组成”，则集合A可表示成： 
A→0 A→1 A→A0 A→A1

### 2.3.2 文法的形式定义

#### 1. 规则（也称产生式）

规则是一个符号与一个符号串的有序对（A,β），通常写作：A→β（或A∷＝ β)  

- 规则的作用：如何用规则中的符号串生成语言中的序列

例：上述例子中的一组规则：
A→0 A→1 A→A0 A→A1
规则中的符号分为两类：

1. 非终结符号

- 出现在规则左部能派生出符号或符号串的那些符号
- 每个非终结符号表示一定符号串的集合，用大写字母表示或用尖括号把非终结符号括起来

例如上例中的A

2. 终结符号

- 不属于非终结符号的那些符号
- 组成语言的基本符号，是一个语言的不可再分的基本符号
- 通常用小写字母表示

例如上例中的0和1   

#### 2. 文法

规则的非空有穷集合，通常表示成四元组G=(VN,VT, P, S )   
N、T为角标

1. VN是规则中非终结符号的集合
1. VT是规则中终结符号的集合
1. P 是文法规则的集合
1. S 是一个非终结符号，称为文法的开始符号或文法的识别符号，它至少要在一条规则中作为左部出现。由它开始，识别出我们所定义的语言

- 文法四大要素中关键是规则的集合
- 为了书写方便，对于若干个左部相同的规则，如A→α1......A→αn，将它们缩写为：A→α1 | … | αn，每个αi有时也称为A的一个候选式
- 第一条规则的左部是识别符号
- 对文法G不用四元式显示表示，仅只将规则写出

例：上述例子中描述∑+的文法是:
G=(VN，VT，P，S )
VN={A}
VT={0，1}
P:  A→ 0 | 1 | A0 | A1
S=A
例1：设字母表∑={a, b}，试设计一个文法，描述语言 L= { a的2n次方, b的2n次方 | n≥1 }
语言L是由偶数个a，偶数个b这样的符号串组成的集合
因此，G=( VN，VT，P，S )
    VN={A, B, D}
    VT={a, b}
    P={ A→aa  | aaB | bb | bbD 
           B→aa | aaB
    D→bb | bbD }
    S=A
    P也可以写作{A→B | D
    B→aa | aBa
    D→bb | bDb}

- 若G和G'是两个不同的文法，如果它们描述的语言相同，那么，称G和G' 为等价文法

上述例子中，若G"=( {A}, {a, b}, P", A )，P"={ A→aa | bb | Aaa | Abb }，对于文法G"来说，它所产生的有些符号串，如aabb，bbaa，…… 不属于语言L，即设计的文法超出了所定义语言的范围
例2：试设计一个表示所有标识符的文法
标识符的结构用“字母+字母或数字串”表示

1. 用I代表标识符；L代表字母；D代表数字

G=(VN，VT，P，S)
VN={I, L, D}
VT={a,b,c, … x,y,z,0,1,2,… ,9}
P={ I→L  | IL | ID
       L→a | b | c | … | x | y | z
D→0 | 1 | 2 | 3 | … | 9 }  
S = I

2. 用I代表标识符；L代表字母；D代表数字；T代表字母数字串

P:  I→L | LT
            T→L | D | LT | DT
            L→a | b | c | …|x|y|z
            D→0 | 1 | 2 | 3 | … | 9
例3：用文法定义一个含＋、*的算术表达式，定义用下述自然语言描述：
变量是一个表达式；
若 E1和 E2是算术表达式, 则E1＋E2、E1*E2、(E1) 也是算术表达式。  
   G=({E},{ i, +, *, (, ) }, P, E )
   P：E→i | E+E |  E*E | (E)
例4：设字母表 Σ={ a, b } , 试设计一个文法，描述语言 L={ a*b的n次方*a | n≥0 }
L={ aa, aba, abba, …… }  
=>G=( {A, B}, {a, b}, P,  A )
      P={ A→aBa  
             B→Bb | ε }
例5：设字母表∑={ (,) } ,试设计一个文法描述语言 L={ (的n次方)的n次方 | n≥0}
L={ ε, ( ), (( )), ((( ))), … }
=>P:   S→ ε | ( S )

### 2.3. 3 语言的形式定义

#### 1. 直接推导

令G是一文法，我们称 xAy直接推导出 xαy ，即 xAy=>xαy 仅 A→α 是 G 的一条规则, 且  
x, y∈(VN∪VT)*。也就是说从符号串 xAy 直接推导出 xαy 仅使用一次规则。  
例：设有文法G[S]：P为：S→ 0 1 | 0 S 1  
S=>01                       使用规则 S=>01，此时   x＝ε，   y＝ε
S=>0S1                     使用规则 S=>0S1 ，此时    x＝ε，  y＝ε
0S1=>0011               使用规则 S=>01  ，此时  x＝0， y＝1
00S11=>000S111      使用规则 S=>0S1,此时  x＝00 ,   y＝11  
000S11100001111   使用规则 S=>01,此时  x＝000, y＝111

- 推导和规则的区别：

1. 形式上的区别，推导用“=>”表示，规则用“->”表示 
1. 对文法G中任何规则A->α，我们有A=>α，即推导的依据是规则

#### 2.推导

如果存在一个直接推导序列： α0=> α1=> α2=> … => αn，则我们称这个序列是一个从α0至αn的长度为n的推导，记为  α0=（+）>αn。表示从α0 出发，经一步或若干步或者说使用若干次规则可推导出 αn
例：设有文法G[E]=({E,T,F},{i,+,*,(,)},P,E)，P为：E→E+T | T     T→T*F | F     F→(E) | i
		对 i+i\*i 有直接推导序列:  E=>E+T=>T+T=>F+T=>i+T=>i+T\*F=>i+F\*F=>i+i\*F=>i+i\*i
		可记为E=（+）>i+i*i

#### 3. 广义推导

α0=（\*）>αn表示从α0出发，经0步或若干步，可推导出αn。意味着α0=（+）>αn或者α0=αn
例：由上述例子可得,E=（\*）>E     E=（\*）>i+i*i

- 三种推导的区别：直接推导的长度为1，推导的长度大于等于1，而广义推导的长度大于等于0

#### 4. 句型和句子

设有文法G[S] (S是文法G的开始符号)，如果S=（\*）>x， x∈(VnUVt)*则称符号串x为文法G[S]的句型。如果s=（\*）>x,x∈Vt\*则称符号串x为文法G[S]的句子
例1：设有文法G[S]: S- >01 |0S1
有: S=（\*）>01    S=（\*）>0S1     S=（\*）>00S11    S=（\*）>000111
例2：设有文法G[E]：E→E+E | E\*E|(E)|i，试证明符号串(i\*iti)是文法G[E]的一个句子
E=>(E)=>(E+E)=>(E\*E+E)=>(i\*E+E)=>(i\*i+E)=>(i*i+i)

#### 5. 语言

文法G[S]产生的所有句子的集合称为文法G所定义的语言,记为L(G[S])：L(G[S])={x|S=（\*）>x且x∈Vt*}

- 一当文法给定,语言也就确定。
- L(G)是Vt\*的子集。即属于Vt*的符号串x不一定属于L(G)

---

#### 6、总结

- 从文法的开始符号出发，反复连续地使用规则替换、展开非终结符，找出句子的规律，用式子或自然语言描述出来。 
- 给定一种语言，能确定其文法，但这种文法不是唯一的，即：L→G1或G2或…
- 给定一个文法，就能从结构上唯一确定其语言，即：G→L(G)；



### 2.3.4 规范推导和规范归约

#### 1、规范推导

- 最右推导是指在推导过程中任何一步α=>β (α和β是句型)，都是对α中的最右非终结符进行替换。
- 最左推导是指在推导过程中任何一步α=>β (α和β是句型), 都是对α的最左非终结符进行替换。
- 最右推导也称为规范推导，用规范推导推导出的句型称为规范句型。



#### 2、规范归约

- 归约是与推导相对的概念
- 归约则是把句型中的某个子串用一个非终结符来替换的过程。 
- 规范推导的逆过程，称为最左归约，也称为规范归约。

#### 3、递归规则

如果文法中有规则
         A→A …    称为规则左递归。
如果文法中有规则
         A→ … A   称为规则右递归。
 如果文法中有规则
        A→ …A… 称为规则递归。
文法的递归性
若文法中有推导A=>+A …称文法左递归。
若文法中有推导A=>+ … A称文法右递归。
若文法中有推导A=>+ … A …称文法递归。


当一个语言是无穷集合时，则定义该语言的文法一定是递归的。 


## 2.4 短语、直接短语和句柄

### 2.4.1短语

       令G是一个文法，S是文法的开始符号，假定αβδ是文法G的一个句型，如果有  ：
S=>*αAδ 且A=>+β     则称 β是相对于非终结符A的, 句型αβδ的短语


### 2.4.2 直接短语

       令G是一个文法，S是文法的开始符号，假定αβδ是文法G的一个句型，如果有  ：S=>*αAδ 且A=>β
则称β是直接短语


### 2.4.3句柄

     一个句型的最左直接短语称为该句型的句柄。
    特征：

      - 它是直接短语，即某规则右部。
      - 它具有最左性。



注：短语、直接短语和句柄都是针对某一句型的，都是指句型中的哪些符号串能构成短语和直接短语，离开具体的句型来谈短语、直接短语和句柄是无意义的。 


## 2.5 语法树与文法二义性

### 2.5.1推导和语法树

#### 1、语法树

-  对句型的推导过程给出一种图形表示, 这种表示称为语法树，也称推导树。      
-  语法树的构造过程是从文法的开始符号出发，构造一个推导的过程。
-  文法的每一个句型 (句子) 都存在一 个推导，所以文法的每个句型(句子) 都存在一棵对应的语法树。
-  一棵语法树表示了一个句型的种种可能的不同推导过程, 包括最左(最右)推导。



#### 2、子树

语法树的子树是由某一结点连同所有分枝组成的部分。
句型的短语、直接短语和句柄的直观解释是：

      -     短语：子树的末端结点形成的符号串相对于子树根的短语。
      -    直接短语：简单子树的末端结点形成符号串是相对于简单子树根的直接短语。
      -    句柄：最左简单子树的末端结点形成的符号串是句柄。



### 2.5.2文法的二义性

如果一个文法存在某个句子对应两棵不同的语法树，则说这个文法是二义性的。
若一个文法中存在某个句子，它有两个不同的最左 (最右) 推导，则这个文法是二义性的。 
E →E+E | E*E | (E) | i


### 2.5.3文法二义性的消除

- 不改变文法中原有的语法规则, 仅加进一些非形式的语法规定。  
- 构造一个等价的无二义性文法。即把排除二义性的规则合并到原有文法中,  改写原有的文法。



文法的二义性和语言的二义性是两个不同的概念。通常我们只说文法的二义性,   而不说语言的二义性,
这是因为可能有两个不同的文法G和G' ，而且其中一个是二义性的，另一个是无二义性的,   但却有L(G)=L(G'), 即这两个文法所产生的语言是相同的。
将一个语言说成是二义性的，是指对它不存在无二义性的文法，这样的语言称为先天二义性的语言。


## 2.6文法和语言的分类

文法和语言分为四大类，即0型、1型、  2型、3型。划分的依据是对文法中的规则施加不同的限制。  

### 3型文法(正规文法)

- 若文法G=(VN,VT, P, S)中的每一条规则的形式 为A →aB 或 A →a , 其中：  A , B∈VN,  a∈ VT*, 则称G是右线性文法。
- 若文法G=(VN,VT, P, S)中的每一条规则的形式   为A →Ba 或 A→ a , 其中：A , B∈VN ,  a∈ VT*, 则称G是左线性文法。 
- 右线性文法和左线性文法都称为3型文法。
- 3型文法也称正规文法。正规文法产生的语言称为正规语言。
- 3型文法描述的语言是3型语言。
- 3型语言由有穷自动机识别。



### 2型文法（上下无关文文法）

- 若文法G=(VN,VT, P, S)中的每一条规则的形式为 A →β , 其中：  A∈VN ,β∈(VN∪VT)* 则称G为二型文法。
- 2型文法又称上下文无关文法，其产生语言又称为上下文无关的语言。
- 2型文法描述的语言是2型语言。
- 2型语言由下推自动机识别。



### 1型文法（上下文有关文法）

- 若文法G=(VN,VT, P, S)中的每一条规则的形式为 αAβ→αμβ , 其中：A∈VN ,  α, β∈(VN∪VT)* , μ∈(VN∪VT)+则称G是1型文法。
- 1型文法也称为上下文有关文法， 相应的语言又称为上下文有关语言。
- 1型文法描述的语言是1型语言。
- 1型语言由线性界限自动机识别。



### 0型文法（无限制文法）

- 若文法G=(VN,VT, P, S)中的每条规则α→β 是这样一种结构：  α∈(VN∪VT)+ ,β ∈(VN∪VT)*而且α中至少含一个非终结符, 则称G是0型文法。
- 0型文法没有加任何限制条件，又称为无限制性文法，相应的语言称为无限制性语言
- 0型语言由图灵机识别。
- 0型文法描述的语言是0型语言。





注：

- 从0型文法到3型文法, 是逐渐增加对规则的限制条件而得到的
- 因此每一种正规文法都是上下文无关的文法，每一种上下文无关的文法都是上下文有关的文法。
- 每一种上下文有关的文法都是0型文法, 而由它们所定义的语言类是依次缩小的，有 L0  ⊃ L1 ⊃ L2 ⊃ L3 。



## 2.7 有关文法的实用限制和变换 

文法是用来描述程序设计语言的，在实际应用中需要对文法加一些限制条件。
1、 文法中不能含有形如A →A 的规则。这种规则我们称之为有害规则。
2、文法中不能有多余规则。所谓多余规则是指文法中出现以下两种规则：

- 某条规则 A→ α 的左部符号A不在所属文法的任何其他规则右部出现，即在推导文法的所有句子中始终都不可能用到的规则。
- 对文法中的某个非终结符A，无法从它推出任何终结符号串来。 



注：若程序设计语言的文法含有多余规则， 其中必定有错误存在，因此检查文法中是否含有多余规则对我们来说是很重要的。 

# 第3章 词法分析与有穷自动机

---

## 3.1词法分析程序的功能

词法分析的任务是对字符串表示的源程序从左到右地进行扫描和分解，根据语言的词法规则识别出一个一个具有独立意义的单词符号。

![d6lNs1.png](https://s1.ax1x.com/2020/08/25/d6lNs1.png)


## 3.2 单词符号及输出单词的形式 

### 3.2.1语言的单词符号

是指语言中具有独立  意义的最小语法单位 。
例：

- 关键字    也称基本字，例如，C语言中  的if，else，while, do等。
- 标识符:   表示各种名字，如变量名、常量名、数组名和函数名等。
- 常数:       各种类型的常数，如整型常数125、实型常数0.718、布尔型常数TRUE等 。
- 运算符  如＋、－、*、/、＜等。  
- 分界符  如 ，、；、（、）、：等 。

### 3.2.2    输出单词的形式

词法分析程序所输出的单词符号通常表示成如下的二元式：单词种别，单词自身的值、


单词种别：单词种别表示单词的种类，它是语法分析需要的信息。
    为处理方便通常让每种单词对应一个整数码。


单词自身的值：一个种别只含一个单词符号
   一个种别含有多个单词符号：

         - 对于标识符其自身值是标识符自身的字符串；  
         - 常数自身值是常数本身的二进制数值。  
         - 用指向某类表格一个特定项目指针值来区分同类中不同的单词。



## 3.3 单词符号的两种定义方式

 1. 正规文法：以标识符为例

    ​	 I→I|II|Id

    ​			或

    ​	 I→I|IT

​			T→l|d|lT|dT

2. 正规式： 以标识符为例:

   ​		I（I | d）*

**         **

### 3.3.1 正规式和正规集

设有字母表Σ={a1, a2,…, an} ，在字母表Σ上的正规式和它所表示的正规集可用下规则来定义：  

- Φ是Σ 上的正规式，它所表示的正规  集是 Φ ，即空集{ }。  
- ε是Σ 上的正规式，它所表示的正规集仅含一空符号串，即{ε}。
- ai是∑上的一个正规式，它所表示的正规集是由单个符号ai 所组成，即{ai}。
- 如果 e1和 e2 是∑上的正规式，它们所表示的正规集分别为 L(e1)和L(e2) ，则：
      1.  e1 | e2是∑上的一个正规式，它所表示的正规集为L(e1 | e2)=L(e1 )∪L(e2)
         2.  e1e2 也是∑上的一个正规式，它所表示的正规集为L(e1e2)=L(e1)L(e2)
         3.   (e1)也是∑上的一个正规式，它所表示的正规集为L((e1))=(L(e1))



注:    正规式中包含三种运算符：
	连接“·”，或“|”和闭包“*”。
	其中闭包运算的优先级最高，连接运算次之，或运算最低。连结符“·”一般可省略不写。这三种运算符         均是左结合的。  

### 3.3.2 正规文法和正规式

#### 1. 正规文法到正规式的转换

- 将正规文法中的每个非终结符表示成关于它的一个正规式方程，获得一个联立方程组。
- 依照求解规则：

若 x = αx | β (或 x = αx + β ) 则解为 x = α*β  
若 x = xα | β (或 x = xα + β ) 则解为 x = βα *
 以及正规式的分配律、交换律和结合律求关于文法开始符号的正规式方程组的解。


#### 2. 正规式到正规文法的转换

- 令 VT=Σ 。
- 对任何正规式R选择一个非终结符Z生成规则Z→R并令S＝Z。
- 若a和b都是正规式，对形如 A→ab 的规则转换成 A箭头aB 和 B箭头b 两规则，其中B是新增的非终结符。
- 对已转换的文法中, 形如A →a*b 的规则，进一步转换 成 A → aA | b 。  
- 不断利用规则(3)和(4)进行变换，直到每条规则最多含有一个终结符为止。



## 3.4正规式与有穷自动机

有穷自动机是具有离散输入与输出系统的一种抽象数学模型。
       有穷自动机有“确定的”和“非确定的”两类，确定的有穷自动机和非确定的有穷自动机都能准确地识别正规集。  


### 3.4.1 确定有穷自动机

- 一个确定有穷自动机M是一个五元组
- M=( Q, Σ, f, S, Z )
- Q是一个有穷状态集合，每一个元素称为一个状态。
- Σ是一个有穷输入字母表，每个元素称为一个输入字符。
- f 是一个从Q∈Σ 到Q的单值映射：f ( qi , a) = qj              (qi , qj ∈ Q,  a ∈ Σ)
- 表示当前状态为qi ，输入字符为a时，自动机将转换到下一个状态qj ,   qj 称为qi 的一个后继状态。



### 3.4.2非确定有穷自动机

- 一个非确定有穷自动机M是一个五元组  M=( Q, Σ, f, S, Z)  
- 其中：Q, ∑, Z 意义同DFA ，f 和 S不同于DFA 。
- 状态转换函数f 不是单值函数,它是一 个多值函数：f(qi ,a) ={某些状态的集合}
- 非确定的有穷自动机还允许f(qi ,ε)={某些状态的集合}。  
- S∈  Q ，是非空初态集。 



我们利用有穷自动机构造词法分析程序的方法是:
从语言单词的描述中构造出非确定的有穷自动机 ε –NFA。

2. 再将非确定的有穷自动机转化为确定的有穷自动机。
2. 并将其化简为状态最少化的DFA 。
2. 然后对DFA的每一个状态构造一小段程序将其转化为识别语言单词的词法分析程序。


### 3.4.3 由正规式R构造NFA 

1.   R=Φ, 构造NFA如图所示。




![d6l8G4.png](https://s1.ax1x.com/2020/08/25/d6l8G4.png)

2.   R= ε , 构造NFA如图所示。  

![d6l3iF.png](https://s1.ax1x.com/2020/08/25/d6l3iF.png)

3.   R= a (aΣ), 构造NFA如图所示。  

![d6lGRJ.png](https://s1.ax1x.com/2020/08/25/d6lGRJ.png)
  4.若R是复合正规式，则按下图的转换规则对R进行分裂和加进新结,  直至每个边上只留下一个符号或 ε 为止。 
![d6lJz9.png](https://s1.ax1x.com/2020/08/25/d6lJz9.png)


### 3.4.4  NFA确定化为DFA的方法 


基本思想;    
对于一个NFA，由于状态转换函数 f 是一个多值函数 ，因此，对于它们有:
f ( q, a)={q1 , q2 , q3…,qn}


该集合是NFA状态集合中的一个子集，为了将NFA转换为DFA，把状态集合{q1 , q2 , q3…, qn}看作一个状态A。
也就是说，DFA的每一个状态代表NFA状态集合的某个子集，这个DFA使用它的状态去记  录在NFA读入输入之后可能到达的所有状态的集合,我们称此构造方法为子集法。  


### 3.4.5 DFA的化简

 1.DFA M 的化简是指寻找一个状态数比 M 少的 DFA  M' ，使得 L(M)=L(M') 。 
并且满足两个条件：

               - 没有多余状态。
               - 它的状态集中没有两个状态是互相等价的。



  2.多余状态: 多余状态是指从该自动机的开始状态出发，任何输入串也不能到达的状态。 


  3.等价状态： 设 DFA M＝(Q,Σ,f, S0, F),  s, t∈ Q ，若对任何a∈Σ *,  f (s , a)∈F 当且仅当
f (t , a)∈F ，则称状态 s 和 t 是等价的。如果 s 和 t 不等价, 则称 s 和 t 是可区别的。


4.   两个状态等价的条件:

一致性条件: 状态s和t必须同时为终态或非终态。
蔓延性条件:  对于所有输入符号a,状态 s 和 t 必须转到等价的状态里。

   5.化简方法  
无多余状态下把M的状态集 Q 分划成一些不相交的子集，使得每个子集中任何两个状态是等价的，而任何两个属于不同子集的状态都是可区别的。然后在每个子集中任取一个状态作“代表”, 而删去子集中其余状态, 并把射向其余状态的箭弧都改作射向作“代表”的状态中。 

### 3.4.6  有穷自动机到正规式的转换 

1. 在 M 的转换图上添加两个结点： X 结和Y结。从X结用ε连线连结到M的所有初态结点，从 M 的所有终态结点用ε连线连结到 Y 结，从而构成一新的非确定有穷自动机 M’，它只有一个初态结 X和一个终态结Y。显然，L(M)=L(M’)。即，这两个NFA是等价的。 
1. 逐步消去M’中的其它结点，直至只剩下X，Y结点。在消除结点过程中，逐步用正规式来标记相应的箭弧。

注：消除结点的过程是很直观的，只需反复使用下图的替换规则即可。
![d6ltMR.png](https://s1.ax1x.com/2020/08/25/d6ltMR.png)

## 3.5 正规文法与有穷自动机 

### 3.5.1 右线性正规文法到有穷自动机的转换方法

设给定了一个右线性正规文法
              G = (VN ,VT , P , S)  
则相应的有穷自穷自动机
             M = (Q , Σ , f , q0 , Z )


1. 令    Q= VN∪{D}   (D  ∉  VN)

Z={D}       Σ = VT      q0=S



2. 对G中每一形如 A→aB (A ,B∈VN ,a∈VT∪{ε})的产生式 , 令 f (A , a)=B



3. 对G中每一形如A→a(A∈VN ,a∈VT)的产生式, 令 f (A , a)=D



4. 对G中每一形如A→ε (A∈VN )的产生式, 令A为接受状态或令 f (A , ε)=D



### 3.5.2 左线性正规文法到有穷自动机的转换方法

设给定了一个左线性正规文法
             G = (VN ,VT , P , S)  
则相应的有穷自穷自动机
            M = (Q , Σ , f , q0 , Z )


1. 令    Q= VN∪{q0}   (q0    VN) Z={S}             Σ = VT



2. 对G中每一形如A→Ba (A ,B∈VN ,a∈VT∪{ε})的产生式, 令 f (B , a)=A



3. 对G中每一形如A→a (A∈VN,  a∈VT∪{ε})的产生式, 令 f (q0 , a) =A



### 3.5.3 有穷自动机到正规文法的转换

设给定有穷自动机M = (Q , Σ , f , q0 , Z )
则相应的正规文法 G = (VN ,VT , P , S)  


1. 令     VN = Q     VT = Σ       S = q0



2. 若f (A,a)=B 且B ∉z     时，则将产生式A→aB 加到P中。



3. 若f (A,a)=B 且B∈Z时，则将产生式A→aB | a 或将产生式A→aB、B→ε加到P中。



4. 若文法的开始符号S是一个终态，则将产生式 S→ε 加到P中。  



## **3.6 词法分析程序的编写方法**

第一种方法是用手工方式，即根据识别语言单词的状态转换图，使用某种高级语言，例如C语言直接编写词法分析程序


第二种方法是利用词法分析程序的自动生成工具LEX自动生成词法分析程序。

注： 只要构造出识别语言单词符号的有穷自动机,  就很容易构造出识别语言单词符号的词法分析程序。      

# 第4章 语法分析

## 4.1 语法分析程序的功能

词法分析后的单词串->语法分析器->语法成分构成的语法树或错误表
语法分析的方法：

1. 自顶向下语法分析法

从文法的开始符号出发，根据文法规则正向推导出给定句子的一种方法；或者说，从树根开始，往下构造语法树，直到建立每个叶的分析方法。  

2. 自底向上语法分析法

      从给定的输入串开始，根据文法规则逐步进行归约，直至归约到文法开始符号的一种方法；或者说，从语法树的未端开始，步步向上归约，直至根结点的分析方法。 

## 4.2 

### 4.2.1 非确定的自上而下分析法的思想 

本质上是一种穷举试探过程，反复使用不同规则，谋求匹配输入串的过程

### 4.2.2 文法的左递归性和回溯的消除

1. 文法左递归的消除                                                                           
   文法左递归是指文法中的某个非终结符A存在推导A =(+)> Aα， 用非终结符A去匹配输入串时,使当前句型的最左非终结符仍然为A。  
   对含直接左递归的规则进行等价变换，消除左递归：
   1.1  引进一个新的非终结符，把含左递归的规则改写成右递归。  
          设关于非终结符A的直接左递归的规则为A→ Aα | β，其中α 、β是任意的符号串, α不等于 ε , β不以A开头，对A的规则可改写成如下右递归形式：  A → βA'     A'→ αA' | ε
   1.2  采用扩充BNF表示法改写含直接左递归的规则：
     在扩充的BNF表示中

      1. 使用花括号{ α }表示符号串α的出现可0次或多次，即表示 α*  
      1. 使用方括号[ α ]表示 α 的出现可有可无，它用来表示可供选择的符号串
      1. 使用圆括号可在规则中提因子
   1. 回溯的消除

在自上而下分析过程中，由于回溯，需要推翻前面的分析，包括已做的一大堆语义工作，重新去进行试探，这样大大降低了语法分析器的工作效率，因此，需要消除回溯

- 回溯的原因是: 在文法中,当某个非终结符A有多个候选式时:A → α1 | α2 | α3 |∙∙∙∙∙∙| αn,遇到用A去匹配当前输入符号a时，无法确定选用唯一的一个候选式，而只能逐一进行试探，从而引起回溯
  1. 文法中相同左部的规则，其右部左端第一个符号相同而引起回溯
  1. 文法中相同左部的规则，其中某一右部能推出ε串
- 在自上而下分析过程中，为了避免回溯，要求描述语言的文法是LL(1)文法

**LL(1)文法的判断条件**

1.  设α是文法G的任一符号串，定义文法符号串α的首符号集合FIRST(α) = { a | α =>a…且 a∈VT }，

若α=（*）>ε，则规定 ε∈ FIRST(α)

2. 设文法G的开始符号为S，对于G的任何非终结符A，定义非终结符A的后继符号的集合FOLLOW(A) ={ a | S 

=（*）> …Aa …且a∈VT }  ，若有S =（*）> …A ,则规定 $∈FOLLOW(A)。

3. 定义规则的选择集合SELECT，设A→ α是文法G的任一条规则，其中A∈VN , α∈(VN∪VT)* ，定义

![d61Ocd.png](https://s1.ax1x.com/2020/08/25/d61Ocd.png) 

- LL(1)文法定义：

一个上下文无关文法 G是LL(1)文法, 当且仅当对 G 中每个非终结符A的任何两个不同的规则 A→ α | β，满足SELECT(A→ α)∩SELECT(A→β) = Φ    ，其中α 、β中至多只有一个能推出ε串。  

- 若文法G[S]是LL(1)文法，则对任何的输入串可进行确定的自上而下分析
- 当描述语言的文法是LL(1)文法时，可对其进行确定的自上而下的分析

### 4.2.3 某些非LL(1)文法到LL(1)文法的改写方法

- 对某些非LL(1)文法而言, 可通过消除左递归和反复提取公共左因子对文法进行等价变换，可能将其改造为 LL(1)文法

### 4.2.4 递归下降分析法

- 递归下降分析法是确定的自上而下分析法，这种分析法要求文法是LL(1)文法
- 对文法中的每个非终结符编写一个函数 (或子程序), 每个函数（或子程序）的功能是识别由该非终结符所表示的语法成分

构造递归下降分析程序的方法:
为每个非终结符编制一个递归下降分析函数，每个函数名是相应的非终结符，函数体则是根据规则右部符号串的结构和顺序编写

1. 当遇到终结符a时，则编写语句 

if  (当前读来的输入符号==a)      
             读下一个输入符号；  

2. 当遇到非终结符A时，则编写语句调用 A( )
2. 当遇到规则A→ε 时，则编写语句 

if (当前读来的输入符号FOLLOW(A))  
           error( )；

4. 当某个非终结符的规则有多个候选式时，按LL(1)文法的条件能唯一地选择一个候选式进行推导

- 优点: 递归下降分析法简单、直观，易于构造分析程序。  
- 缺点: 对文法要求高，必须是LL(1)文 法，同时由于递归调用较多，影响分析器的效率。

### 4.2.5  预测分析法与预测分析表的构造

- 预测分析法(LL(1)分析法)是确定的自上而下分析的另一种方法，采用这种方法进行语法分析要求描述语言的文法是LL(1)文法

![d61q9e.png](https://s1.ax1x.com/2020/08/25/d61q9e.png)

1. 输入缓冲区T[j]中存放待分析的输入符号串，它以右界符 ‘$’ 或‘#’作为结束。
1. 分析栈S[K]中存放替换当前非终结符的某规则右部符号串，句子左界符‘$’或‘#’存入栈底
1. 预测分析表是一个二维形式的矩阵，其中矩阵的行为文法非终结符，矩阵的列为文法终结符或‘$’或‘#’ 
1. 预测分析器的总控程序在任何时候都是根据栈顶符号和当前输入符号a来决定分析器的动作

![d61L1H.png](https://s1.ax1x.com/2020/08/25/d61L1H.png)

- 预测分析器的总控程序对于不同的LL(1)文法都是相同的，而预测分析表对于不同的LL(1)文法是不相同的

构造预测分析表的方法：
输入: 文法G
输出: 预测分析表M  

   1. 计算文法G的每一非终结符的FIRST集和FOLLOW集
   1. 对文法的每个规则A→α, 若a∈FIRST(α),则置M[A, a]= A→ α 
   1. 若ε∈FIRST(α), 则对任b∈FOLLOW(A),则置M[A, b]= A→ α 
   1. 把分析表中每个未定义的元素标上出 错标志error（表中用空白格表示）

- 若一个文法G的分析表M不含多重定义元素, 则该文法是LL(1)文法
- 预测分析法的主要优点是 LL(1)分析表比其他分析方法中的分析表相对要小一些

## 4.3 自下而上分析法的一般原理

**编译中存在着多种自下而上的分析法，但不管哪种自下而上的分析法都是按照移进—归约法的原理建立起来的一种语法分析方法。**
基本思想：
![d61HhD.png](https://s1.ax1x.com/2020/08/25/d61HhD.png)

- 自下而上分析法的关键问题是如何精确定义可归约串这个直观概念，以及怎样识别“可归约串”。



- 对“可归约串”的不同定义形成不同的自下而上的分析方法,在规范归约分析法中，是用句柄来刻画可归约串,而在算符优先分析法中,是用最左素短语来刻画可归约串。



- 识别可归约串的不同方法，也同样形成不同的自下而上的分析方法, 简单优先分析法和LR分析法都是规范归约分析法，即都是用句柄刻画可归约串。



- LR分析法是根据历史、现实、展望三者信息来确定栈顶符号串是否形成句柄。



- 简单优先分析法是根据文法符号之间的优先关系来确定栈顶符号串是否形成句柄。 

## 4.4 算符优先分析法

### 4.4.1 方法概述

- 算符优先分析法就是仿照算术表达式的四则运算过程而设计的一种语法分析方法。



- 这种分析方法首先要规定运算符之间(确切地说终结符之间)的优先关系和结合性质，然后借助这种关系，比较相邻运算符的优先级来确定句型的可归约串并进行归约



- 算符优先分析法的关键在于用合适的方法去定义任何两个可能相邻出现的终结符号a和b之间的优先关系。



- 任何两个相邻终结符号a 和 b之间的优先关系有三种：

![d614n1.png](https://s1.ax1x.com/2020/08/25/d614n1.png)

- 注意,优先关系与出现的左右次序有关,这一点是不同于数学中的＜,＝和＞。

### 4.4.2 算符优先文法的定义

**1.算符文法的定义**

设有文法G, 若G中没有形如U→…VW…的规则，其中V和W为非终结符，则称G为算符文法，也称OG文法。
       也就是说，在算符文法中，任何一个规则右部都不存在两个非终结符相邻的情况。  

**2.定义任意两个终结符号之间的优先关系**

设G是一个算符文法，a和b是任意两个终结符，P、Q、R是非终结符，算符优先关系  <.   =.、>.  定义如下： 

1. a=.b    当且仅当G中含有形如 P→…ab…或 P→…aQb…的规则。
1. a<.b    当且仅当G中含有形如  P→…aR…的规则, 且R=>+b或R=>+Qb
1. a>.b    当且仅当G中含有形如P→…Rb…的规则，且R=>+a或R=>aQ

**3.算符优先文法的定义**

设有一个不含ε规则的算符文法G，如果任意两个终结符号对(a，b)在   <.  、>.   和 =.   三种关系中只有一种关系成立，则称G是算符优先文法，也称OPG文法。  


对前述算术表达式的文法:       E→E+E | E*E | (E) | id
     由算符文法和算符优先文法的定义，我们不难证明该文法是一个算符文法，但不是算符优先文法。  


注：即运算符+和*之间存在两种不同的优先关系，所以该表达式的文法仅是算符文法而不是算符优先文法。
## 

### 4.4.3 算符优先关系表的构造

   对算符优先文法,根据优先关系的定义,可按如下方法直接构造优先关系表。  
首先对文法每个非终结符Ａ定义两个集合：
FIRSTVT(A)={b | A=>+b…或A=>+Bb…,b∈VT , B∈VN }
LASTVT(A)={a | A=>…a 或A =>…aB,  a∈VT, B∈VN }  


使用这两个集合，构造文法Ｇ的优先关系表的算法如下： 
输入：算符优先文法Ｇ
输出：关于文法Ｇ的优先关系表

方法：
1.为每个非终结符Ａ计算FIRSTVT(A)和LASTVT(A)  
2 .执行程序
![d617tO.png](https://s1.ax1x.com/2020/08/25/d617tO.png)

3. 对 FIRSTVT(S)中的所有b，置$ <.  b;
       对 LASTVT(S)中的所有a，置a .> $；  
       置$  =.$ （S为文法开始符号）  

### 4.4.4 算符优先分析算法的设计

**1. 最左素短语**

算符优先分析法不是用句柄来刻画可归约串，而是用最左素短语来刻画可归约串的。
所谓句型的素短语是指这样一种短语，它至少包含一个终结符，并且除自身之外，不再包含其它的素短语。句型最左边的素短语称最左素短语。

**2. 识别句型最左素短语的方法**

由算符文法的定义可知，算符优先文法的任何句型都没有相邻的两个非终结符。
其句型总可以表示成：
$ N1a1 N2a2 … Nnan Nn+1$   
其中每个Ni为非终结符或空, ai为终结符（1≤i≤n）


一个算符优先文法G的任何句型的最左素短语是满足下列条件的最左子串
算符文法的任何句型中终结符和非终结符相邻时含终结符的短语必含相邻非终结符。 

**3. 算符优先分析程序的设计**

 根据最左素短语的定理，最左素短语中的终结符号具有相同的优先关系，并且，由于最左素短语中的符号是当时最先要归约的串，其优先关系先于最左素短语之外的符号，所以我们使用一个用于存放文法符号的先进后出栈，并利用优先关系表，可以确定最左素短语是否已形成来决定分析器的动作。  

基本思想：

![d6150x.png](https://s1.ax1x.com/2020/08/25/d6150x.png)


输入：输入符号串W和优先关系表。
输出：若W是正确的句子，则接收，否则输出错误信息。  
方法：执行下图算法
![d61TAK.png](https://s1.ax1x.com/2020/08/25/d61TAK.png)

### 4.4.5 优先函数的构造

   算符优先分析法中，文法终结符之间的优先关系用矩阵表示，当有n个终结符时，需要（n+1）2个内存单元(含$)。如果使用优先函数 代替优先矩阵，只需2（n+1)个单元。

### 4.4.6 算符优先分析法的局限性

     由于算符优先分析法跳过了所有单非产生式之间的归约，这样算符优先分析比规范归约要快得多，这既是优点也是缺点。由于忽略非终结符在归约过程中的作用，可能导致把本来不是句子的输入串误认为是文法句子。  

## 4.5 LR分析法

- LR分析法是一种自下而上进行规范归约的语法分析方法。
- 这里L是指从左到右扫描输入符号串。R是指构造最右推导的逆过程。
- 这种分析法比递归下降分析法、预测分析法和算符优先分析法对文法的限制要少得多。  
- 大多数用无二义性上下文无关文法描述的语言都可以用LR分析法进行有效的分析

### 4.5.1 LR分析器的逻辑结构和工作过程

基本思想：    
LR分析法是一种规范归约分析法。
规范归约分析法的关键是在分析过程中如何确定分析栈栈顶的符号串是否形成句柄。
根据分析栈中记录的已移进和归约出的整个符号串和根据使用的规则推测未来可能遇到的输入符号以及         现实读到的输入符号这三个方面的信息来确定分析栈栈顶的符号串是否构成句柄。 

LR分析器的逻辑结构
它由分析栈、分析表和总控程序3个部分组成。  
![d61I76.png](https://s1.ax1x.com/2020/08/25/d61I76.png)

**1.分析栈**

分析栈用来存放分析过程中的历史和展望信息。
分析栈中的每个状态概括了从分析开始到某一归约阶段的整个分析历史和对未来进行的展望。 

**2. LR分析表  **

- LR分析表是LR分析器的核心部分。  
- 一张LR分析表由分析动作(ACTION)表和状态转换( GOTO )表两部分组成，它们都是二维数组。
- 状态转换表元素GOTO[Si , X]规定了当状态Si面临文法符号X时，应转移到的下一个状态。  
- 分析动作表元素ACTION[Si , a]规定了当状态Si面临输入符号a时应执行的动作。 
- 分析动作表对应四种可能动作：  移进  归纳 接受 报错

**3. 总控程序  **

- 总控程序也称为驱动程序。  
- 对所有的LR分析器其总控程序是相同的。
- 总控程序从左至右扫描输入符号串，并根据当前分析栈中栈顶状态以及当前读   到的输入符号按照LR分析表元素所指示的动作完成每一步的分析工作。  



总控程序算法：
输入：输入串W和LR分析表。  
输出：若W是句子，得到W的自下而上分析成功，否则输出错误信息。  
算法：初始化时，初始状态S0在分析栈栈顶，输入串W$的第1个符号读入a中。  

### 4.5.2  LR（0）分析法

- LR(0)分析就是在分析的每一步，只需根据当前栈顶状态而不必向前查看输入符号就能确定应采取的分析动作。  
- 构造LR分析表的基本思想是:     从给定的上下文无关文法直接构造识别文法所有规范句型活前缀的DFA，然后再将DFA转换成一张LR分析表。  
- 字符串的前缀是指字符串的任意首部。
- 当所分析的输入串没有语法错误时，则在分析的每一步，分析栈中已移进—归约的全部文法符号与余留的输入符号串合起来，就是所给文法的一个规范句型。 
- 在LR分析过程中的任何时刻，栈中的文法符号应是某一规范句型的活前缀

---

- LR分析器的工作过程可看成是一个逐步识别所给文法规范句型活前缀的过程

活前缀与句柄之间的关系有下述三种情况：

1. 活前缀中已含有句柄的全部符号，表明此时某一规则A→α的右部符号串α已出现在栈顶，其相应的分析动作是用此规则进行归约
1. 活前缀中只含有句柄的一部分符号，此时意味着形如 A→α1α2 规则的右部子串，α1已出现在栈顶，α2正期待着从余留的输入串中进行归约得到
1. 活前缀中全然不含有句柄的任何符号，此时意味着期望从余留输入串能看到由某规则 A→α 的右部 α 所推出的符号串

- 为了刻画在分析过程中, 文法的一个规则右部符号串已有多大一部分被识别，我们可在文法中每个规则右部适当位置上加一个圆点来表示。针对上述三种情况，标有圆点的规则分别为：A→α·    A→ α1 · α2      A→·α
- 文法G中右部标有圆点的规则称为G的一个LR(0)项目
- 对空规则 A→ε，仅有LR(0)项目A→• 
- 一个LR(0)项目指明了对文法规范句型活前缀的不同识别状态

由于不同的LR(0)项目反映了在分析过程中栈顶的不同情况，因此，可以根据圆点位置和圆点后是终结符还是非终结符，将一个文法的全部LR(0)项目进行分类：

1. 归约项目，形如A→α•，其中α∈(VN∪VT)*，即圆点在最右端的项目，它表示一个规则的右部已分析完, 句柄已形成，应该按此规则进行归约
1. 移进项目，形如A→α• aβ，其中α， β∈(VN∪VT)* ，即圆点后面为终结符的项目, 它表示期待从输入串中移进一个符号，以待形成句柄
1. 待约项目，形如A→α• Bβ，其中α， β∈(VN∪VT) * , B ∈VN ,即圆点后面为非终结符的项目，它表示期待从余留的输入串中进行归约得到B，然后分析A的右部
1. 接受项目，形如S'→S• ，其中S'为文法的开始符号，即文法开始符号的归约项目。 S'为左部的规则仅只有一个，它是归约项目的特殊情况，它表示整个句子已经分析完毕，可以接受

构造识别文法所有规范句型活前缀DFA的方法 :

- 对于构成识别文法规范句型活前缀DFA的每一个状态是由若干个LR(0)项目所组成的集合，称为LR(0)项目集。在这个项目集中，所有的LR(0)项目识别的活前缀是相同的，可以利用闭包函数（CLOSURE）来求DFA一个状态的项目集。

为了使“接受”项目唯一，对文法G进行拓广。假定文法G的开始符号为S，在文法G中引入一个新的开始符号S'，并加进一个新的规则S' →S，从而得到文法G的拓广文法G'

1. 定义闭包函数 

设I是拓广文法G'的一个LR(0)项目集，定义和构造I的闭包CLOSURE(I)如下：  

      1. I中的任何一个项目都属于CLOSURE(I)
      1. 若A→α• Bβ属于CLOSURE(I)，则每一形如 B →•γ的项目也属于CLOSURE(I)
      1. 重复(b)直到CLOSURE(I)不再增大为止
   1. 定义状态转移函数GO 

设I是拓广文法G'的任一个项目集，X为一文法符号，定义状态转移函数GO(I,X)如下： 
GO( I , X )=CLOSURE( J )
J={A→aX·β | A→a·X β∈I}

3. 构造识别文法规范句型活前缀DFA的方法 :
   1. 求CLOSURE{S'→•S}，得到初态项目集
   1. 对初态项目集或其它已构造的项目集，应用状态转移函数GO(I,X)，求出新的项目集（后继状态）
   1. 重复(b)直到不出现新的项目集（新状态）为止
   1. 转移函数GO建立状态之间的连结关系

- DFA中的每一个状态都是终态
- 当M到达它们时,  识别出某规范句型的一个活前缀，对那些只含归约项目的项目集, 当M到达这些状态时，表示已识别出一个句柄,  这些状态称为句柄识别态
- 当M处于状态I1时，M识别的活前缀为S，表示输入串已成功分析完毕，用S'→S进行最后一次归约，称状态为接受状态
- 构成识别一个文法活前缀的DFA的状态（项目集）的全体称为这个文法的LR(0)项目集规范族

4. LR(0)分析表的构造 ：

- 若一个文法G的拓广文法G'的LR(0)项目集规范族中的每个项目集不存在移进项目和归约项目同时并存或多个归约项目同时并存，则称G为LR(0)文法

对LR(0)文法，构造LR(0)分析表的算法如下： 
输入：识别LR(0)文法G规范句型活前缀的DFA  
输出：文法G的LR(0)分析表  
方法：用整数 0, 1, 2, …，n 分别表示状态 I0, I1, I2 …, In, 令包含项目S'→•S 的集合 Ik 的下标为分析器的初始状态。  

   1. 若项目A→α•xβ属于 Ik, 且转换函数  GO(Ik , x)=Ii , 当 x 为终结符时，则置ACTION[k, x]=Si
   1. 若GO(Ik , A)=Ij , A为非终符，则置GOTO[k, A]=j
   1. 若项目A→α•属于Ik ，则对任何终  结符和结束符$（统一记为a）则置ACTION[k, x]=rj  （假定A→α为文法的第j条规则）  
   1. 若项目S'→S •属于Ik，则置    ACTION[k, $]=acc
   1. 分析表中凡不能用规则1至4填入信息的元素均置为“出错标志”，为了  分析表的清晰，仅用空白表示出错标志。  

- LR(0)分析器的特点是不需要向前查看输入符号就能归约，即当栈顶形成句柄，不管下一个输入符号是什么，都可以立即进行归约而不会发生错误

### 4.5.3  SLR（1）分析法

- 对含有冲突的项目集向前查看一个输入符号来解决移进—归约或归约—归约冲突，这种分析法称为简单的LR分析法，即SLR(1)分析法
- 如果对于一个文法的某些LR(0)项目集或LR(0)分析表中所含有的动作冲突都能用SLR(1)方法解决，则称这个文法是SLR(1)文法

SLR(1)分析表的构造与LR(0)分析表的构造基本相同。仅对LR(0)分析表构造算法中的规则2进行如下修改： 
若归约项目A→α•属于Ik，则对任何终结符 a ∈ FOLLOW(A)，置 ACTION[k, a]=rj，其中A→α为文法的第j条规则。  

- 若文法的SLR(1)分析表不含多重定义元素，则称文法G为SLR(1)文法











































