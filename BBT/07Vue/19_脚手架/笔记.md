## 脚手架文件结构
│  .gitignore git版本管制忽略的文件
│  babel.config.js bable的配置文件
│  package-lock.json 包版本控制文件
│  package.json 应用包配置文件
│  README.md 应用描述文件
│
├─public
│      favicon.ico 页签图标
│      index.html 主页面
│
└─src
    │  App.vue 汇总所有组件
    │  main.js 入口文件
    │
    ├─assets 存放静态资源
    │      logo.png
    │
    └─components 存放组件
            HelloWorld.vue

- public 静态网页和网站页签图标 不能改
- src/assets 静态资源：图片、视频
- src/components 组件
- src/main.js 入口文件  不能改
- .gitignore 配置不被git识别的文件
- babel.config.js ES6转ES5，babel的配置
- package.json 包的说明
  - 短命令
    - server 启动项目
    - build 构建，转换成.html、.css、.js
    - lint 语法检查
- package-lock.json 包的版本控制
- README.md 项目说明
- vue.config.js 自定义配置文件，包括修改入口文件为其他文件

## 关于不同版本vue的说明
- 关于不同版本的Vue:
  - 1.vue,js与vue,runtime.xxx,js的区别：
    - (1).vue.js是完整版的Vue,包含：核心功能+模板解析器。
    - (2).vue.runtime.xxx.js是运行版的Vue,只包含：核心功能：没有模板解析器。
  - 2.因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用
    - render函数接收到的createElement函数去指定具体内容，

## vue.config.js配置文件
> 终端输入 vue inspect > output.js，显示webpack的默认配置文件。运行报错就删除“vue.ps1”
> 使用vue.config,js可以对脚手架进行个性化定制，详情见：https:/cli.vuejs.org/zh

## ref属性
  1. 被用来给元素或子组件注册引用信息(id的替代者)
  2. 应用在htm1标签上获取的是真实DOM给元素，应用在组件标签上是组件实例对象(vc)
  3. 使用方式：
     1. 打标识：<h1ref="xxx">....</h1>或<Schoo1ref="xxx"></School>
     2. 获取：this.$refs.xxx

## 配置项props
- 功能：让组件接收外部传过来的数据
  - (1).传递数据：
      ```javascript
      <Demo name="xxx"/>
      ```
  - (2).接收数据：
    - 第一种方式（只接收）：
        ```javascript
        props:['name']
        ```
    - 第二种方式（限制类型）：
        ```javascript
        props:{
          name:String
        }
        ```
    - 第三种方式（限制类型、限制必要性、指定默认值）：：
        ```javascript
        props:{
          name:{
            type:String,//类型
            required:true//必要性
            default:'老王'//默认值
          }
        }
        ```
  - 备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，
      若业务需求确实需要修改，那么请复制propsi的内容到data中一份，然后去修改data中
      的数据。

## mixin(混入)
- 功能：可以把多个组件共用的配置提取成一个混入对象
- 使用方式：
  - 第一步定义混合，例如：
    ```javascript
    {
      data(){.…},
      methods:{....}
    }
    ```
  - 第二步使用混入，例如：
    ```javascript
    (1).全局混入：Vue.mixin(xxx)
    (2).局部混入：mixins:[xxx]
    ```

## 插件
- 功能：用于增强Vue
- 本质：包含insta11方法的一个对象，instal1的第一个参数是Vue,第二个以后的参数是插件使用者传递的数据。
- 定义插件：
  ```javascript
  对象.install=function(Vue,options){
    //1.添加全局过滤器
    Vue.filter(....)
    //2.添加全局指令
    Vue.directive(....)
    //3.配置全局混入（合）
    Vue.mixin(....)
    //4.添加实例方法
    Vue.prototype.SmyMethod function (){...}
    Vue.prototype.SmyProperty xxxx
  }
  ```
- 使用插件：Vue.use()

## scoped样式
- 作用：让样式在局部生效，防止冲突。
- 写法：
  ```javascript
  <style scoped>
  ```

## 总结TodoList案例
1. 组件化编码流程：
   - (1).拆分静态组件：组件要按照功能点拆分，命名不要与tm元素冲突。
   - (2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：
     - 1).一个组件在用：放在组件自身即可。
     - 2).一些组件在用：放在他们共同的父组件上（状态提升）。
   - (3).实现交互：从绑定事件开始。
2. propsi适用于：
   - (1)父组件=>子组件通信
   - (2)子组件=>父组件通信（要求父先给子一个函数）
3. 使用v-model时要切记：v-mode绑定的值不能是props传过来的值，因为props是不可以修改的！
4. props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。

## webStorage
1.  存储内容大小一般支持5MB左右（不同浏览器可能还不一样）
2. 浏览器端通过Window.sessionStorage和Window.localStorage属性来实现本地存储机制。
3. 相关API:
   2. xxxxxStorage.getItem('person');该方法接受一个键名作为参数，返回键名对应的值。
   3. xxxxxStorage.removeItem('key');该方法接受一个键名作为参数，并把该键名从存储中删除。
   4. xxxxxStorage.clear();该方法会清空存储中的所有数据。
4. 备注：
   1. SessionStorage存储的内容会随着浏览器窗口关闭而消失，
   2. LocalStorage存储的内容，需要手动清除才会消失。
   3. xxxxxStorage.getItem(xxx)如果Xox对应的value获取不到，那么getltemi的返回值是nul.
   4. JSONN.parse(nul1)的结果依然是null。

## 组件的自定义事件
1. 一种组件间通信的方式，适用于：**子组件=>父组件**
2. 使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）。
3. 绑定自定义事件：
   1. 第一种方式，在父组件中：
        ```javascript 
        <Demo eatguigu="test"/> 
        ```
        或
        ```javascript 
        <Demo v-on:atguigu="test"/>
         ```
   2. 第二种方式，在父组件中：
        ```javascript
        <Demo ref="demo"/>
        ......
        mounted(){
          this.Srefs.xxx.Son('atguigu',this.test)
        }
        ```
   3. 若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法。
4. 触发自定义事件：this.$emit('atguigu',数据)
5. 解绑自定义事件this.$off('atguigu')
6. 组件上也可以绑定原生DOM事件，需要使用native修饰符。
7. 注意：通过this.$refs.xx.son('atguigu',回调)绑定自定义事件时，回调**要么配置在methods中，要么用箭头函数**，否则this指向会出问题！


## 全局事件总线
1. 一种组件间通信的方式，适用于任意组件间通信。
2. 安装全局事件总线：
   ```javascript
      new Vue({
        .....
        beforeCreate(){
          Vue.prototype.$bus = this//安装全局事件总线，Sbus就是当前应用的vm
        },
        .....
      }
    ```
3. 使用事件总线：
   1. 接收数据：A组件想接收数据，则在A组件中给Sus绑定自定义事件，事件的回调留在A组件自身。
      ```javascript
          methods(){
            demo(data){......}
          }
          .....
          mounted(){
            this.$bus.$on('xxxx',this.demo)
          }
      ```
   2. 提供数据：
      ```javascript
        this.$bus.$emit('xxxx',数据)
      ```
4. 最好在beforeDestroy钩子中，用$off去解绑**当前组件所用到的**事件。

## 消息订阅与发布（pubsub）
1. 一种组件间通信的方式，适用于**任意组件间通信**。
2. 使用步骤：
   1. 安装pubsub:npm i pubsub-js
   2. 引入：import pubsub from 'pubsub-js'
   3. 接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的**回调留在A组件自身**。
      ```javascript
      methods: {
        demo(data){......}
      }
      .....
      mounted(){
        this.pid = pubsub.subscribe('xxx',this.demo)//订阅消息
      }
      ```
   4. 提供数据：pubsub.publish('xxx',数据)
   5. 最好在beforeDestroy钩子中，用PubSub.unsubscribe(pid)去**取消订阅**

## nextTick
1. 语法：
   ```javascript
    this.$nextTick(回调函数)
   ```
2. 作用：在下一次DOM更新结束后执行其指定的回调。
3. 什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。

## Vue封装的过度与动画
1. 作用：在插入、更新或移除DOM元素时,在合适的时候给元素添加样式类名。
2. 写法：
   1. 准备好样式：
      - 元素进入的样式：
        1. v-enter:进入的起点
        2. v-enter-.active:进入过程中
        3. v-enter-to:进入的终点
      - 元素离开的样式：
        1. v-leave:离开的起点
        2. v-leave-active:离开过程中
        3. V-leave-to:离开的终点
   2. 使用<transition>包裹要过度的元素，并配置name属性：
    ```javascript
    <transition name="hello">
      <h1 v-show="isShow">你好啊！</h1>;
    </transition>
    ```
   3. 备注：若有多个元素需要过度，则需要使用：<transition-group>,且每个元素都要指定key值.


## vue脚手架配置代理
### 方法一
在vue.config.js中添加如下配置：
```javascript
  devServer:{
    proxy:"http://localhost:5000"
  }
```
说明：
1. 优点：配置简单，该求资源时直接发给前端(8080)即可。
2. 缺点：不能配置多个代理，不能灵活的控制请求是否走代理，
3. 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器（优先匹配前端资源）
### 方法二
编写vue.config.js配置具体代理规则：
```javascript
  module.exports = {
    devServer:{
      proxy: {
        '/api1':{//匹配所有以"/api'开头的请求路径
          target:'http://localhost:50e0',//代理目标的基础路径
          changeOrigin:true,
          pathRewrite:{'/api1':''}
        },
        '/api2':{//匹配所有以"/api'开头的请求路径
          target: 'http://localhost:5001',//代理目标的基础路径
          changeOrigin:true,
          pathRewrite:{'/api2':''}
        }
      }
    }
  }
```

## 插槽
1. 作用：让父组件可以向子组件指定位置插入html结构也是一种组件间通信的方式，适用于**父组件==>子组件**。
2.分类： 默认插槽、具名插槽、作用域插槽
3. 使用方式：
   1. 默认插槽：
    ```html
      <!-- 父组件中， -->
        <Category>
          <div>html结构1</div>
        </Category>
      <!-- 子组件中： -->
        <template>
          <div>
            <!--定义插槽-->
            <slot>插槽默认内容..</slot>
          </div>
        </template>
    ```
   2. 具名插槽：
    ```html
      <!-- 父组件中， -->
      <Category>
        <template slot="center">
          <div>html结构1</div>
        </template>
        <template v-slot:footer>
          <div>htm1结构2</div>
        </template>
      </Category>
      子组件中：
      <template>
        <div>
          <!--定义插槽-->
          <slot name="center"插槽默认内容..</s1ot>
          <slot name="footer"插槽默认内容..</slot>
        </div>
      </template>
    ```
    3. 作用域插槽：
      1. 理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。(games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定)
      2. 具体编码：
        ```html
          <!-- 父组件中： -->
          <Category>
            <template scope="scopeData">
              <!-- 生成的是u1列表 -->
              <u1>
                <li v-for="g in scopeData.games"key="g">((g))</li>
              </u1>
            </template>
          </Category>
          <Category>
            <template slot-scope="scopeData">
              <!-- 生成的是h4标题 -->
              <h4 v-for="g in scopeData.games"key="g">({g)}</h4>
            </template>
          </Category>
          <!-- 子组件中， -->
          <template>
            <div>
              <slot :games="games"></slot>
            </div>
          </template>
          <script>
          export default {
            name:'Category',
            props:['title'],
            //数据在子组件自身
            data(){
              return {
                games:['红色警戒'，穿越火线'，‘劲舞团'，'超级玛丽']
              }
            }
          }
        ```

## Vuex
### 3. 搭建vuex环境
1. 创建文件：src/store/index.js
   ```javascript
      //引入Vue核心库
      import Vue from 'vue'
      //引入vuex
      import Vuex from 'vuex'
      //应用Vuex插件
      Vue.use(Vuex)

      //准备actions对象——应组件中用户的动作
      const actions = {}
      //准备mutations对象——修改state中的数据
      const mutations = {}
      //准备state对象——保存具体的数据
      const state = {}
      //创建并暴露store
      export default new Vuex.Store({
        actions,
        mutations,
        state
      })
2. 在main.js中创建vm时传入store配置项
   ```javascript
      ....
      //引入store
      import store from './store'
      ````
      
      //创建vm
      new Vue({
        el:'#app',
        render:h =>h(App),
        store
      })
    ```

### 4. 基本使用
1. 初始化数据、配置actions、配置mutations,操作文件store.js
   ```javascript
    //引入vue核心库
    import Vue from 'vue'
    //引入Vuex
    import Vuex from 'vuex'
    //引用vuex
    Vue.use(Vuex)

    const actions = {
      //响应组件中加的动作
      jia(context,value){
        //console.log('actions中的jia被调用了'，miniStore,value)
        context.commit('JIA',value)
      }
    }

    const mutations = {
      //执行加
      JIA(state,value){
        //console.log('mutations中的)IA被调用了'，state,value)
        state.sum += value
      }
    }

    //初始化数据
    const state = {
      sum: 0
    }

    //创建并暴露store
    export default new Vuex.Store({})
    ```
2. 组件中读取vuex中的数据：$store.state.sum
3. 组件中修改Vuex中的数据：\$store.dispatch('action中的方法名'，数据)或$store.commit('mutations中的方法名'，数据)
    > 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions,即不写dispatch,直接编写commit
### 5. getters的使用
1. 概念：当state中的数据需要经过加工后再使用时，可以使用getters加工，
2. 在store.js中追加getters配置
   ```javascript
    .....
    const getters = {
      bigSum(state){
        return state.sum*10
      }
    }

    //创建并暴露store
    export default new Vuex.Store({
      ....
      getters
    })
  ```
3.组件中读取数据：$store.getters.bigSum

### 6. 四个map方法的使用
1. mapState方法：用于帮助我们映射state中的数据为计算属性
  ```javascript
    computed:{
      //借助mapState生成计算属性：sum、school、subject(对象写法)
      ...mapState({sum:'sum',school:'school',subject:'subject'}),
      //借助mapState生成计算属性：sum、school、subject(数组写法)
      ...mapState(['sum','school','subject']),
    }
  ```
2. mapGetters方法：用于帮助我们映射getters中的数据为计算属性
   ```javascript
    computed:{
      //借助mapGetters.生成计算属性：bigSum(对象写法)
      ...mapGetters({bigSum:'bigSum'}),
      //借mapGetters生成计算属性：bigSum(数组写法)
      ...mapGetters(['bigSum'])
    }
  ```
3. mapActions方法：用于帮助我们生成与actions对话的方法，即：包含$store.dispatch(xxx)的函数
   ```javascript
    methods:{
      //靠napActions:生成：increment0dd、incrementWait(对象形式)
      ...mapActions({incrementodd:'jiaOdd',incrementWait:'jiaWait'})
      //靠mapActions:生成：incrementodd、incrementWait(数组形式)
      ...mapActions(['jiaOdd','jiaWait'])
    }
  ```

4. mapMutations:方法：用于帮助我们生成与mutations对话的方法，即：包含$store.commit(xxx)的函数
   ```javascript
      methods:{
        //靠mapActionss生成：increment、decrement(对象形式)
        ...mapMutations({increment:'JIA',decrement:'JIAN'}),
        //靠mapMutations:生成：JIA、JIAW(对象形式)
        ...mapMutations(['JIa','JIAN'])，
      }
  ```
> 备注：mapActions与mapMutationst使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。


### 7. 模块化+命名空间
1. 目的：让代码更好维护，让多种数据分类更加明确。
2. 修改store.js
  ```javascript
    const countAbout = {
      namespaced:true,//开启命名空间
      state:{×:1},
      mutations:{...},
      actions:{...},
      getters: {
        bigSum(state){
          return state.sum * 10
        }
      }
    }
    const personAbout = {
      namespaced:true,//开启命名空间
      state:{...},
      mutations:{...},
      actions:{...},
    }
    const store = new Vuex.Store({
      modules:{
        countAbout,
        personAbout
      }
    })
  ```
3. 开启命名空间后，组件中读取state数据：
   ```javascript
    //方式一：自己直接读取
    this.Sstore.state.personAbout.list
    //方式二：借助mapState读取，
    ...mapState('countAbout',['sum','school','subject']),
  ```
4. 开启命名空间后，组件中读取getters数据：
  ```javascript
    //方式一：自己直接读取
    this.$store.getters['personAbout/firstPersonName']
    //方式二：借助mapGetters读取：
    ...mapGetters('countAbout',['bigSum'])
  ```
5. 开启命名空间后，组件中调用dispatch
  ```javascript
    //方式-：自己直接dispatch
    this.$store.dispatch('personAbout/addPersonwang',person)
    //方式二：借助mapActions:
    ...mapActions('countAbout',{incrementOdd:'jiaOdd',incrementwait:'jiaWait'})
  ```
6. 开启命名空间后，组件中调用commit
  ```javascript
    //方式一：自己直接commit
    this.$store.commit('personAbout/ADD_PERSON',person)
    //方式二：借助mapMutations:
    ...mapMutations('countAbout',{increment:'JA',decrement:'JIAN'}),
  ```