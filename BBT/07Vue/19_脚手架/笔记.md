## 脚手架文件结构
│  .gitignore git版本管制忽略的文件
│  babel.config.js bable的配置文件
│  package-lock.json 包版本控制文件
│  package.json 应用包配置文件
│  README.md 应用描述文件
│
├─public
│      favicon.ico 页签图标
│      index.html 主页面
│
└─src
    │  App.vue 汇总所有组件
    │  main.js 入口文件
    │
    ├─assets 存放静态资源
    │      logo.png
    │
    └─components 存放组件
            HelloWorld.vue

- public 静态网页和网站页签图标 不能改
- src/assets 静态资源：图片、视频
- src/components 组件
- src/main.js 入口文件  不能改
- .gitignore 配置不被git识别的文件
- babel.config.js ES6转ES5，babel的配置
- package.json 包的说明
  - 短命令
    - server 启动项目
    - build 构建，转换成.html、.css、.js
    - lint 语法检查
- package-lock.json 包的版本控制
- README.md 项目说明
- vue.config.js 自定义配置文件，包括修改入口文件为其他文件

## 关于不同版本vue的说明
- 关于不同版本的Vue:
  - 1.vue,js与vue,runtime.xxx,js的区别：
    - (1).vue.js是完整版的Vue,包含：核心功能+模板解析器。
    - (2).vue.runtime.xxx.js是运行版的Vue,只包含：核心功能：没有模板解析器。
  - 2.因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用
    - render函数接收到的createElement函数去指定具体内容，

## vue.config.js配置文件
> 终端输入 vue inspect > output.js，显示webpack的默认配置文件。运行报错就删除“vue.ps1”
> 使用vue.config,js可以对脚手架进行个性化定制，详情见：https:/cli.vuejs.org/zh

## ref属性
  1. 被用来给元素或子组件注册引用信息(id的替代者)
  2. 应用在htm1标签上获取的是真实DOM给元素，应用在组件标签上是组件实例对象(vc)
  3. 使用方式：
     1. 打标识：<h1ref="xxx">....</h1>或<Schoo1ref="xxx"></School>
     2. 获取：this.$refs.xxx

## 配置项props
- 功能：让组件接收外部传过来的数据
  - (1).传递数据：
      ```javascript
      <Demo name="xxx"/>
      ```
  - (2).接收数据：
    - 第一种方式（只接收）：
        ```javascript
        props:['name']
        ```
    - 第二种方式（限制类型）：
        ```javascript
        props:{
          name:String
        }
        ```
    - 第三种方式（限制类型、限制必要性、指定默认值）：：
        ```javascript
        props:{
          name:{
            type:String,//类型
            required:true//必要性
            default:'老王'//默认值
          }
        }
        ```
  - 备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，
      若业务需求确实需要修改，那么请复制propsi的内容到data中一份，然后去修改data中
      的数据。

## mixin(混入)
- 功能：可以把多个组件共用的配置提取成一个混入对象
- 使用方式：
  - 第一步定义混合，例如：
    ```javascript
    {
      data(){.…},
      methods:{....}
    }
    ```
  - 第二步使用混入，例如：
    ```javascript
    (1).全局混入：Vue.mixin(xxx)
    (2).局部混入：mixins:[xxx]
    ```

## 插件
- 功能：用于增强Vue
- 本质：包含insta11方法的一个对象，instal1的第一个参数是Vue,第二个以后的参数是插件使用者传递的数据。
- 定义插件：
  ```javascript
  对象.install=function(Vue,options){
    //1.添加全局过滤器
    Vue.filter(....)
    //2.添加全局指令
    Vue.directive(....)
    //3.配置全局混入（合）
    Vue.mixin(....)
    //4.添加实例方法
    Vue.prototype.SmyMethod function (){...}
    Vue.prototype.SmyProperty xxxx
  }
  ```
- 使用插件：Vue.use()

## scoped样式
- 作用：让样式在局部生效，防止冲突。
- 写法：
  ```javascript
  <style scoped>
  ```

## 总结TodoList案例
1. 组件化编码流程：
   - (1).拆分静态组件：组件要按照功能点拆分，命名不要与tm元素冲突。
   - (2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：
     - 1).一个组件在用：放在组件自身即可。
     - 2).一些组件在用：放在他们共同的父组件上（状态提升）。
   - (3).实现交互：从绑定事件开始。
2. propsi适用于：
   - (1)父组件=>子组件通信
   - (2)子组件=>父组件通信（要求父先给子一个函数）
3. 使用v-model时要切记：v-mode绑定的值不能是props传过来的值，因为props是不可以修改的！
4. props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。

## webStorage
1.  存储内容大小一般支持5MB左右（不同浏览器可能还不一样）
2. 浏览器端通过Window.sessionStorage和Window.localStorage属性来实现本地存储机制。
3. 相关API:
   2. xxxxxStorage.getItem('person');该方法接受一个键名作为参数，返回键名对应的值。
   3. xxxxxStorage.removeItem('key');该方法接受一个键名作为参数，并把该键名从存储中删除。
   4. xxxxxStorage.clear();该方法会清空存储中的所有数据。
4. 备注：
   1. SessionStorage存储的内容会随着浏览器窗口关闭而消失，
   2. LocalStorage存储的内容，需要手动清除才会消失。
   3. xxxxxStorage.getItem(xxx)如果Xox对应的value获取不到，那么getltemi的返回值是nul.
   4. JSONN.parse(nul1)的结果依然是null。

## 组件的自定义事件
1. 一种组件间通信的方式，适用于：**子组件=>父组件**
2. 使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）。
3. 绑定自定义事件：
   1. 第一种方式，在父组件中：
        ```javascript 
        <Demo eatguigu="test"/> 
        ```
        或
        ```javascript 
        <Demo v-on:atguigu="test"/>
         ```
   2. 第二种方式，在父组件中：
        ```javascript
        <Demo ref="demo"/>
        ......
        mounted(){
          this.Srefs.xxx.Son('atguigu',this.test)
        }
        ```
   3. 若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法。
4. 触发自定义事件：this.$emit('atguigu',数据)
5. 解绑自定义事件this.$off('atguigu')
6. 组件上也可以绑定原生DOM事件，需要使用native修饰符。
7. 注意：通过this.$refs.xx.son('atguigu',回调)绑定自定义事件时，回调**要么配置在methods中，要么用箭头函数**，否则this指向会出问题！


## 全局事件总线
1. 一种组件间通信的方式，适用于任意组件间通信。
2. 安装全局事件总线：
   ```javascript
      new Vue({
        .....
        beforeCreate(){
          Vue.prototype.$bus = this//安装全局事件总线，Sbus就是当前应用的vm
        },
        .....
      }
    ```
3. 使用事件总线：
   1. 接收数据：A组件想接收数据，则在A组件中给Sus绑定自定义事件，事件的回调留在A组件自身。
      ```javascript
          methods(){
            demo(data){......}
          }
          .....
          mounted(){
            this.$bus.$on('xxxx',this.demo)
          }
      ```
   2. 提供数据：
      ```javascript
        this.$bus.$emit('xxxx',数据)
      ```
4. 最好在beforeDestroy钩子中，用$off去解绑**当前组件所用到的**事件。

## 消息订阅与发布（pubsub）
1. 一种组件间通信的方式，适用于**任意组件间通信**。
2. 使用步骤：
   1. 安装pubsub:npm i pubsub-js
   2. 引入：import pubsub from 'pubsub-js'
   3. 接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的**回调留在A组件自身**。
      ```javascript
      methods: {
        demo(data){......}
      }
      .....
      mounted(){
        this.pid = pubsub.subscribe('xxx',this.demo)//订阅消息
      }
      ```
   4. 提供数据：pubsub.publish('xxx',数据)
   5. 最好在beforeDestroy钩子中，用PubSub.unsubscribe(pid)去**取消订阅**

## nextTick
1. 语法：
   ```javascript
    this.$nextTick(回调函数)
   ```
2. 作用：在下一次DOM更新结束后执行其指定的回调。
3. 什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。
